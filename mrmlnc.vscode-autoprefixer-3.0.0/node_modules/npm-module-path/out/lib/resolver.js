'use strict';
const path = require("path");
const utils_1 = require("./utils");
const finder_1 = require("./finder");
function resolveOneModule(toResolve, paths, options) {
    return Promise
        .all(paths.map((dir) => utils_1.pathExists(path.join(dir, toResolve))))
        .then((resolves) => {
        for (let index = 0; index < resolves.length; index++) {
            if (resolves[index]) {
                const modulePath = utils_1.normalize(paths[index]);
                return options.resolveDir ? modulePath : modulePath + '/' + toResolve;
            }
        }
        return '';
    });
}
exports.resolveOneModule = resolveOneModule;
function resolveOneModuleByPrefix(toResolve, options) {
    return finder_1.getNodePrefix().then((prefix) => {
        const globalModules = [path.join(prefix, utils_1.getNodeModulesDir())];
        return resolveOneModule(toResolve, globalModules, options);
    }).then((result) => {
        if (result === '') {
            return undefined;
        }
        return result;
    });
}
exports.resolveOneModuleByPrefix = resolveOneModuleByPrefix;
function resolveManyModules(toResolve, paths, options, skipTry) {
    const promises = toResolve.map((name) => {
        return Promise.all(paths.map((dir) => utils_1.pathExists(path.join(dir, name))));
    });
    return Promise.all(promises).then((resolves) => {
        const result = [];
        const toContinue = [];
        resolves.forEach((resolve, moduleIndex) => {
            const moduleName = toResolve[moduleIndex];
            const trueIndex = resolve.indexOf(true);
            if (trueIndex !== -1) {
                const modulePath = utils_1.normalize(paths[trueIndex]);
                result.push(options.resolveDir ? modulePath : modulePath + '/' + moduleName);
                return;
            }
            result.push(undefined);
            toContinue.push(moduleName);
        });
        if (toContinue.length !== 0 && !skipTry) {
            return resolveManyModuleByPrefix(toContinue, options, true).then((resultByPrefix) => {
                return result.map((filepath) => {
                    return filepath === undefined ? resultByPrefix.shift() : filepath;
                });
            });
        }
        return (result.length !== 0) ? result : [''];
    });
}
exports.resolveManyModules = resolveManyModules;
function resolveManyModuleByPrefix(toResolve, options, skipTry) {
    return finder_1.getNodePrefix().then((prefix) => {
        const globalModules = [path.join(prefix, utils_1.getNodeModulesDir())];
        return resolveManyModules(toResolve, globalModules, options, skipTry);
    });
}
exports.resolveManyModuleByPrefix = resolveManyModuleByPrefix;
